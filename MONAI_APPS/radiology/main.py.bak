import json
import logging
import os
import importlib
from typing import Dict

import lib.configs
from lib.activelearning import Last
from lib.infers.deepgrow_pipeline import InferDeepgrowPipeline
from lib.infers.vertebra_pipeline import InferVertebraPipeline
from lib.configs import DeepEdit, DeepEditWeld

import monailabel
from monailabel.interfaces.app import MONAILabelApp
from monailabel.interfaces.config import TaskConfig
from monailabel.interfaces.datastore import Datastore
from monailabel.interfaces.tasks.infer_v2 import InferTask
from monailabel.interfaces.tasks.scoring import ScoringMethod
from monailabel.interfaces.tasks.strategy import Strategy
from monailabel.interfaces.tasks.train import TrainTask
from monailabel.tasks.activelearning.first import First
from monailabel.tasks.activelearning.random import Random
from monailabel.tasks.infer.bundle import BundleInferTask
from monailabel.tasks.train.bundle import BundleTrainTask
from monailabel.utils.others.class_utils import get_class_names
from monailabel.utils.others.generic import get_bundle_models, strtobool
from monailabel.utils.others.planner import HeuristicPlanner

logger = logging.getLogger(__name__)


class MyApp(MONAILabelApp):
    def __init__(self, app_dir, studies, conf):
        self.model_dir = os.path.join(app_dir, "model")

        # -----------------------------
        # DETECCIÓN ROBUSTA DE MODELOS
        # -----------------------------
        configs = {}
        for c in get_class_names(lib.configs, "TaskConfig"):
            try:
                # c debería ser algo como 'lib.configs.deepedit.DeepEdit'
                parts = c.split(".")
                if len(parts) >= 2:
                    # penúltimo componente: nombre del módulo (deepedit, deepgrow_2d, ...)
                    name = parts[-2].lower()
                else:
                    # fallback por si el formato no es el esperado
                    name = parts[-1].lower().replace("lib.configs.", "")
                # si hay colisiones, la última definición ganará (o podrías manejar de otra forma)
                configs[name] = c
            except Exception as e:
                logger.warning(f"⚠️ Error procesando clase devuelta por get_class_names: {c} -> {e}")

        if not configs:
            logger.error("❌ No se encontraron configuraciones válidas en lib.configs")
        else:
            logger.info(f"✅ Configs detectadas: {list(configs.keys())}")

        configs = {k: v for k, v in sorted(configs.items())}

        models = conf.get("models")
        if not models:
            print("\n---------------------------------------------------------------------------------------")
            print("Provide --conf models <name>")
            print("Following are the available models. You can pass comma (,) separated names to load multiple:")
            print(f"    all, {', '.join(configs.keys())}")
            print("---------------------------------------------------------------------------------------\n")
            exit(-1)

        models = [m.strip() for m in models.split(",")]
        self.scribbles = conf.get("scribbles", "true") == "true"

        invalid = [m for m in models if m != "all" and not configs.get(m)]
        if invalid:
            print("\n---------------------------------------------------------------------------------------")
            print(f"Invalid Model(s) provided: {invalid}")
            print(f"Available: all, {', '.join(configs.keys())}")
            print("---------------------------------------------------------------------------------------\n")
            exit(-1)

        # Heuristic planner
        spatial_size = json.loads(conf.get("spatial_size", "[48, 48, 32]"))
        target_spacing = json.loads(conf.get("target_spacing", "[1.0, 1.0, 1.0]"))
        self.heuristic_planner = strtobool(conf.get("heuristic_planner", "false"))
        self.planner = HeuristicPlanner(spatial_size=spatial_size, target_spacing=target_spacing)

        # app models
        self.models: Dict[str, TaskConfig] = {}
        for n in models:
            for k, v in configs.items():
                if self.models.get(k):
                    continue
                if n == k or n == "all":
                    logger.info(f"+++ Adding Model: {k} => {v}")
                    # Instanciar de forma segura usando importlib
                    try:
                        module_name, class_name = v.rsplit(".", 1)
                        mod = importlib.import_module(module_name)
                        cls = getattr(mod, class_name)
                        instance = cls()
                        self.models[k] = instance
                    except Exception as e:
                        logger.error(f"❌ No se pudo instanciar {v}: {e}")
                        continue

                    # Llamar init si existe (algunas versiones lo usan)
                    try:
                        if hasattr(self.models[k], "init") and callable(getattr(self.models[k], "init")):
                            self.models[k].init(k, self.model_dir, conf, self.planner)
                        else:
                            # Si no hay init, lo registramos y seguimos (muchas TaskConfig exposen métodos sin init)
                            logger.warning(f"ℹ️ El modelo '{k}' no define método init(); se asume que no es necesario.")
                    except Exception as e:
                        logger.warning(f"⚠️ Llamada a init() para modelo '{k}' falló: {e}")

        logger.info(f"+++ Using Models: {list(self.models.keys())}")

        # Bundles
        self.bundles = get_bundle_models(app_dir, conf, conf_key="bundles") if conf.get("bundles") else None

        # SAM2 disabled
        self.sam = False

        super().__init__(
            app_dir=app_dir,
            studies=studies,
            conf=conf,
            name=f"MONAILabel - Radiology ({monailabel.__version__})",
            description="Deep Learning models for radiology (no SAM2)",
            version=monailabel.__version__,
        )

    def init_datastore(self) -> Datastore:
        datastore = super().init_datastore()

        # FORZAR REFRESCO E INFO PARA DEBUG
        try:
            # Si el datastore tiene un método refresh() lo llamamos
            if hasattr(datastore, "refresh"):
                logger.info("Datastore: calling refresh()")
                datastore.refresh()
            # Intentar obtener info (si existe API interna)
            try:
                info = datastore.info() if hasattr(datastore, "info") else None
                logger.info(f"Datastore info returned: {info}")
            except Exception:
                logger.info("Datastore.info() not available or failed; skipping.")
        except Exception as e:
            logger.warning(f"Datastore refresh failed: {e}")

        if self.heuristic_planner:
            self.planner.run(datastore)
        return datastore

    def init_infers(self) -> Dict[str, InferTask]:
        infers: Dict[str, InferTask] = {}

        # Models
        for n, task_config in self.models.items():
            try:
                c = task_config.infer()
                c = c if isinstance(c, dict) else {n: c}
                for k, v in c.items():
                    logger.info(f"+++ Adding Inferer:: {k} => {v}")
                    infers[k] = v
            except Exception as e:
                logger.warning(f"⚠️ Falló al obtener infer() del modelo {n}: {e}")

        # Bundles
        if self.bundles:
            for n, b in self.bundles.items():
                i = BundleInferTask(b, self.conf)
                logger.info(f"+++ Adding Bundle Inferer:: {n} => {i}")
                infers[n] = i

        # Scribbles
        if self.scribbles:
            from monailabel.scribbles.infer import GMMBasedGraphCut, HistogramBasedGraphCut
            labels = list(self.models.values())[0].labels if self.models else {}

            infers.update(
                {
                    "Histogram+GraphCut": HistogramBasedGraphCut(
                        intensity_range=(-300, 200, 0.0, 1.0, True),
                        pix_dim=(2.5, 2.5, 5.0),
                        lamda=1.0,
                        sigma=0.1,
                        num_bins=64,
                        labels=labels,
                    ),
                    "GMM+GraphCut": GMMBasedGraphCut(
                        intensity_range=(-300, 200, 0.0, 1.0, True),
                        pix_dim=(2.5, 2.5, 5.0),
                        lamda=5.0,
                        sigma=0.5,
                        num_mixtures=20,
                        labels=labels,
                    ),
                }
            )

        # Pipelines
        if infers.get("deepgrow_2d") and infers.get("deepgrow_3d"):
            infers["deepgrow_pipeline"] = InferDeepgrowPipeline(
                path=self.models["deepgrow_2d"].path,
                network=self.models["deepgrow_2d"].network,
                model_3d=infers["deepgrow_3d"],
                description="Combines Deepgrow 2D and 3D models",
            )

        if (
            infers.get("localization_spine")
            and infers.get("localization_vertebra")
            and infers.get("segmentation_vertebra")
        ):
            infers["vertebra_pipeline"] = InferVertebraPipeline(
                task_loc_spine=infers["localization_spine"],
                task_loc_vertebra=infers["localization_vertebra"],
                task_seg_vertebra=infers["segmentation_vertebra"],
                description="Three-stage vertebra segmentation pipeline",
            )

        logger.info(infers)
        return infers

    def init_trainers(self) -> Dict[str, TrainTask]:
        trainers: Dict[str, TrainTask] = {}
        if strtobool(self.conf.get("skip_trainers", "false")):
            return trainers

        for n, task_config in self.models.items():
            try:
                t = task_config.trainer()
                if not t:
                    continue
                logger.info(f"+++ Adding Trainer:: {n} => {t}")
                trainers[n] = t
            except Exception as e:
                logger.warning(f"⚠️ Falló al obtener trainer() del modelo {n}: {e}")

        if self.bundles:
            for n, b in self.bundles.items():
                t = BundleTrainTask(b, self.conf)
                if not t or not t.is_valid():
                    continue
                logger.info(f"+++ Adding Bundle Trainer:: {n} => {t}")
                trainers[n] = t
        return trainers

    def init_strategies(self) -> Dict[str, Strategy]:
        strategies: Dict[str, Strategy] = {
            "random": Random(),
            "first": First(),
            "last": Last(),
        }

        if strtobool(self.conf.get("skip_strategies", "true")):
            return strategies

        for n, task_config in self.models.items():
            try:
                s = task_config.strategy()
                if not s:
                    continue
                s = s if isinstance(s, dict) else {n: s}
                for k, v in s.items():
                    logger.info(f"+++ Adding Strategy:: {k} => {v}")
                    strategies[k] = v
            except Exception as e:
                logger.warning(f"⚠️ Falló al obtener strategy() del modelo {n}: {e}")

        logger.info(f"Active Learning Strategies:: {list(strategies.keys())}")
        return strategies

    def init_scoring_methods(self) -> Dict[str, ScoringMethod]:
        methods: Dict[str, ScoringMethod] = {}
        if strtobool(self.conf.get("skip_scoring", "true")):
            return methods

        for n, task_config in self.models.items():
            try:
                s = task_config.scoring_method()
                if not s:
                    continue
                s = s if isinstance(s, dict) else {n: s}
                for k, v in s.items():
                    logger.info(f"+++ Adding Scoring Method:: {k} => {v}")
                    methods[k] = v
            except Exception as e:
                logger.warning(f"⚠️ Falló al obtener scoring_method() del modelo {n}: {e}")

        logger.info(f"Active Learning Scoring Methods:: {list(methods.keys())}")
        return methods


def main():
    from monailabel.utils.others.generic import device_list
    print("✅ MONAI Label Radiology app (SAM2 disabled) initialized successfully.")


if __name__ == "__main__":
    main()
